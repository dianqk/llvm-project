; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt < %s -passes=memcpyopt -S -verify-memoryssa | FileCheck %s

define i24 @forward_load(ptr %src) {
; CHECK-LABEL: define i24 @forward_load(
; CHECK-SAME: ptr [[SRC:%.*]]) {
; CHECK-NEXT:    [[DEST:%.*]] = alloca [3 x i8], align 1
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr [[DEST]], ptr [[SRC]], i64 3, i1 false)
; CHECK-NEXT:    [[VAL1:%.*]] = load i24, ptr [[SRC]], align 4
; CHECK-NEXT:    ret i24 [[VAL1]]
;
  %dest = alloca [3 x i8]
  call void @llvm.memcpy.p0.p0.i64(ptr %dest, ptr %src, i64 3, i1 false)
  %val = load i24, ptr %dest
  ret i24 %val
}

define i16 @forward_load_2(ptr %src) {
; CHECK-LABEL: define i16 @forward_load_2(
; CHECK-SAME: ptr [[SRC:%.*]]) {
; CHECK-NEXT:    [[DEST:%.*]] = alloca [3 x i8], align 1
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr [[DEST]], ptr [[SRC]], i64 2, i1 false)
; CHECK-NEXT:    [[VAL1:%.*]] = load i16, ptr [[SRC]], align 2
; CHECK-NEXT:    ret i16 [[VAL1]]
;
  %dest = alloca [3 x i8]
  call void @llvm.memcpy.p0.p0.i64(ptr %dest, ptr %src, i64 2, i1 false)
  %val = load i16, ptr %dest
  ret i16 %val
}

define i32 @forward_load_padding(ptr %src) {
; CHECK-LABEL: define i32 @forward_load_padding(
; CHECK-SAME: ptr [[SRC:%.*]]) {
; CHECK-NEXT:    [[DEST:%.*]] = alloca { i8, i32 }, align 8
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr [[DEST]], ptr [[SRC]], i64 8, i1 false)
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr inbounds i8, ptr [[DEST]], i64 4
; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr inbounds i8, ptr [[SRC]], i64 4
; CHECK-NEXT:    [[VAL1:%.*]] = load i32, ptr [[TMP1]], align 4
; CHECK-NEXT:    ret i32 [[VAL1]]
;
  %dest = alloca { i8, i32 }
  call void @llvm.memcpy.p0.p0.i64(ptr %dest, ptr %src, i64 8, i1 false)
  %gep = getelementptr inbounds i8, ptr %dest, i64 4
  %val = load i32, ptr %gep
  ret i32 %val
}

; Negative tests

define i24 @failed_forward_load_write_src(ptr %src) {
; CHECK-LABEL: define i24 @failed_forward_load_write_src(
; CHECK-SAME: ptr [[SRC:%.*]]) {
; CHECK-NEXT:    [[DEST:%.*]] = alloca [3 x i8], align 1
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr [[DEST]], ptr [[SRC]], i64 3, i1 false)
; CHECK-NEXT:    store i1 true, ptr [[SRC]], align 1
; CHECK-NEXT:    [[VAL:%.*]] = load i24, ptr [[DEST]], align 4
; CHECK-NEXT:    ret i24 [[VAL]]
;
  %dest = alloca [3 x i8]
  call void @llvm.memcpy.p0.p0.i64(ptr %dest, ptr %src, i64 3, i1 false)
  store i1 true, ptr %src
  %val = load i24, ptr %dest
  ret i24 %val
}

define i16 @failed_forward_load_size(ptr %src) {
; CHECK-LABEL: define i16 @failed_forward_load_size(
; CHECK-SAME: ptr [[SRC:%.*]]) {
; CHECK-NEXT:    [[DEST:%.*]] = alloca [3 x i8], align 1
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr [[DEST]], ptr [[SRC]], i64 1, i1 false)
; CHECK-NEXT:    [[VAL:%.*]] = load i16, ptr [[DEST]], align 2
; CHECK-NEXT:    ret i16 [[VAL]]
;
  %dest = alloca [3 x i8]
  call void @llvm.memcpy.p0.p0.i64(ptr %dest, ptr %src, i64 1, i1 false)
  %val = load i16, ptr %dest
  ret i16 %val
}

define i32 @failed_forward_load_padding(ptr %src) {
; CHECK-LABEL: define i32 @failed_forward_load_padding(
; CHECK-SAME: ptr [[SRC:%.*]]) {
; CHECK-NEXT:    [[DEST:%.*]] = alloca { i8, i32 }, align 8
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr [[DEST]], ptr [[SRC]], i64 5, i1 false)
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr inbounds i8, ptr [[DEST]], i64 4
; CHECK-NEXT:    [[VAL:%.*]] = load i32, ptr [[GEP]], align 4
; CHECK-NEXT:    ret i32 [[VAL]]
;
  %dest = alloca { i8, i32 }
  call void @llvm.memcpy.p0.p0.i64(ptr %dest, ptr %src, i64 5, i1 false)
  %gep = getelementptr inbounds i8, ptr %dest, i64 4
  %val = load i32, ptr %gep
  ret i32 %val
}

declare void @llvm.memcpy.p0.p0.i64(ptr, ptr, i64, i1)
