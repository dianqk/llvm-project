; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt < %s -passes=instcombine -S | FileCheck %s

define i24 @forward_load(ptr align 4 %src) {
; CHECK-LABEL: define i24 @forward_load(
; CHECK-SAME: ptr align 4 [[SRC:%.*]]) {
; CHECK-NEXT:    [[DEST:%.*]] = alloca [3 x i8], align 1
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) [[DEST]], ptr noundef nonnull align 4 dereferenceable(3) [[SRC]], i64 3, i1 false)
; CHECK-NEXT:    [[VAL1:%.*]] = load i24, ptr [[DEST]], align 4
; CHECK-NEXT:    ret i24 [[VAL1]]
;
  %dest = alloca [3 x i8]
  call void @llvm.memcpy.p0.p0.i64(ptr %dest, ptr %src, i64 3, i1 false)
  %val = load i24, ptr %dest
  ret i24 %val
}

define i8 @forward_load_gep(ptr %src) {
; CHECK-LABEL: define i8 @forward_load_gep(
; CHECK-SAME: ptr [[SRC:%.*]]) {
; CHECK-NEXT:    [[DEST:%.*]] = alloca [3 x i8], align 1
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) [[DEST]], ptr noundef nonnull align 1 dereferenceable(3) [[SRC]], i64 3, i1 false)
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr inbounds nuw i8, ptr [[DEST]], i64 2
; CHECK-NEXT:    [[VAL:%.*]] = load i8, ptr [[GEP]], align 1
; CHECK-NEXT:    ret i8 [[VAL]]
;
  %dest = alloca [3 x i8]
  call void @llvm.memcpy.p0.p0.i64(ptr %dest, ptr %src, i64 3, i1 false)
  %gep = getelementptr inbounds i8, ptr %dest, i64 2
  %val = load i8, ptr %gep
  ret i8 %val
}

define i17 @forward_load_padding(ptr %src) {
; CHECK-LABEL: define i17 @forward_load_padding(
; CHECK-SAME: ptr [[SRC:%.*]]) {
; CHECK-NEXT:    [[DEST:%.*]] = alloca [5 x i8], align 1
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) [[DEST]], ptr noundef nonnull align 1 dereferenceable(3) [[SRC]], i64 3, i1 false)
; CHECK-NEXT:    [[VAL:%.*]] = load i17, ptr [[DEST]], align 4
; CHECK-NEXT:    ret i17 [[VAL]]
;
  %dest = alloca [5 x i8]
  call void @llvm.memcpy.p0.p0.i64(ptr %dest, ptr %src, i64 3, i1 false)
  %val = load i17, ptr %dest
  ret i17 %val
}

define <2 x i8> @forward_load_vector(ptr %src) {
; CHECK-LABEL: define <2 x i8> @forward_load_vector(
; CHECK-SAME: ptr [[SRC:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = load <2 x i8>, ptr [[SRC]], align 1
; CHECK-NEXT:    ret <2 x i8> [[TMP1]]
;
  %dest = alloca <2 x i8>
  call void @llvm.memcpy.p0.p0.i64(ptr %dest, ptr %src, i64 2, i1 false)
  %val = load <2 x i8>, ptr %dest
  ret <2 x i8> %val
}

; Negative tests

define i24 @forward_load_volatile(ptr %src) {
; CHECK-LABEL: define i24 @forward_load_volatile(
; CHECK-SAME: ptr [[SRC:%.*]]) {
; CHECK-NEXT:    [[DEST:%.*]] = alloca [3 x i8], align 1
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) [[DEST]], ptr noundef nonnull align 1 dereferenceable(3) [[SRC]], i64 3, i1 false)
; CHECK-NEXT:    [[VAL:%.*]] = load volatile i24, ptr [[DEST]], align 4
; CHECK-NEXT:    ret i24 [[VAL]]
;
  %dest = alloca [3 x i8]
  call void @llvm.memcpy.p0.p0.i64(ptr %dest, ptr %src, i64 3, i1 false)
  %val = load volatile i24, ptr %dest
  ret i24 %val
}

define i24 @failed_forward_load_write_src(ptr %src) {
; CHECK-LABEL: define i24 @failed_forward_load_write_src(
; CHECK-SAME: ptr [[SRC:%.*]]) {
; CHECK-NEXT:    [[DEST:%.*]] = alloca [3 x i8], align 1
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) [[DEST]], ptr noundef nonnull align 1 dereferenceable(3) [[SRC]], i64 3, i1 false)
; CHECK-NEXT:    store i1 true, ptr [[SRC]], align 1
; CHECK-NEXT:    [[VAL:%.*]] = load i24, ptr [[DEST]], align 4
; CHECK-NEXT:    ret i24 [[VAL]]
;
  %dest = alloca [3 x i8]
  call void @llvm.memcpy.p0.p0.i64(ptr %dest, ptr %src, i64 3, i1 false)
  store i1 true, ptr %src
  %val = load i24, ptr %dest
  ret i24 %val
}

define i24 @failed_forward_load_write_dest(ptr %src) {
; CHECK-LABEL: define i24 @failed_forward_load_write_dest(
; CHECK-SAME: ptr [[SRC:%.*]]) {
; CHECK-NEXT:    [[DEST:%.*]] = alloca [3 x i8], align 1
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) [[DEST]], ptr noundef nonnull align 1 dereferenceable(3) [[SRC]], i64 3, i1 false)
; CHECK-NEXT:    store i1 true, ptr [[DEST]], align 1
; CHECK-NEXT:    [[VAL:%.*]] = load i24, ptr [[DEST]], align 4
; CHECK-NEXT:    ret i24 [[VAL]]
;
  %dest = alloca [3 x i8]
  call void @llvm.memcpy.p0.p0.i64(ptr %dest, ptr %src, i64 3, i1 false)
  store i1 true, ptr %dest
  %val = load i24, ptr %dest
  ret i24 %val
}

define i16 @failed_forward_load_size(ptr %src) {
; CHECK-LABEL: define i16 @failed_forward_load_size(
; CHECK-SAME: ptr [[SRC:%.*]]) {
; CHECK-NEXT:    [[DEST:%.*]] = alloca [3 x i8], align 1
; CHECK-NEXT:    [[TMP1:%.*]] = load i8, ptr [[SRC]], align 1
; CHECK-NEXT:    store i8 [[TMP1]], ptr [[DEST]], align 1
; CHECK-NEXT:    [[VAL:%.*]] = load i16, ptr [[DEST]], align 2
; CHECK-NEXT:    ret i16 [[VAL]]
;
  %dest = alloca [3 x i8]
  call void @llvm.memcpy.p0.p0.i64(ptr %dest, ptr %src, i64 1, i1 false)
  %val = load i16, ptr %dest
  ret i16 %val
}

define i8 @failed_forward_load_gep(ptr %src) {
; CHECK-LABEL: define i8 @failed_forward_load_gep(
; CHECK-SAME: ptr [[SRC:%.*]]) {
; CHECK-NEXT:    [[DEST:%.*]] = alloca [3 x i8], align 1
; CHECK-NEXT:    [[TMP1:%.*]] = load i16, ptr [[SRC]], align 1
; CHECK-NEXT:    store i16 [[TMP1]], ptr [[DEST]], align 1
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr inbounds nuw i8, ptr [[DEST]], i64 2
; CHECK-NEXT:    [[VAL:%.*]] = load i8, ptr [[GEP]], align 1
; CHECK-NEXT:    ret i8 [[VAL]]
;
  %dest = alloca [3 x i8]
  call void @llvm.memcpy.p0.p0.i64(ptr %dest, ptr %src, i64 2, i1 false)
  %gep = getelementptr inbounds i8, ptr %dest, i64 2
  %val = load i8, ptr %gep
  ret i8 %val
}

define i8 @failed_forward_load_gep_multi_use(ptr %src) {
; CHECK-LABEL: define i8 @failed_forward_load_gep_multi_use(
; CHECK-SAME: ptr [[SRC:%.*]]) {
; CHECK-NEXT:    [[DEST:%.*]] = alloca [3 x i8], align 1
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) [[DEST]], ptr noundef nonnull align 1 dereferenceable(3) [[SRC]], i64 3, i1 false)
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr inbounds nuw i8, ptr [[DEST]], i64 2
; CHECK-NEXT:    [[VAL1:%.*]] = load i8, ptr [[GEP]], align 1
; CHECK-NEXT:    call void @use_ptr(ptr nonnull [[GEP]])
; CHECK-NEXT:    ret i8 [[VAL1]]
;
  %dest = alloca [3 x i8]
  call void @llvm.memcpy.p0.p0.i64(ptr %dest, ptr %src, i64 3, i1 false)
  %gep = getelementptr inbounds i8, ptr %dest, i64 2
  %val = load i8, ptr %gep
  call void @use_ptr(ptr %gep)
  ret i8 %val
}

define i24 @failed_forward_load_must_alias(ptr %src) {
; CHECK-LABEL: define i24 @failed_forward_load_must_alias(
; CHECK-SAME: ptr [[SRC:%.*]]) {
; CHECK-NEXT:    [[SRC_GEP:%.*]] = getelementptr inbounds nuw i8, ptr [[SRC]], i64 2
; CHECK-NEXT:    [[DEST_GEP:%.*]] = getelementptr inbounds nuw i8, ptr [[SRC]], i64 2
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) [[DEST_GEP]], ptr noundef nonnull align 1 dereferenceable(3) [[SRC_GEP]], i64 3, i1 false)
; CHECK-NEXT:    [[VAL:%.*]] = load i24, ptr [[DEST_GEP]], align 4
; CHECK-NEXT:    ret i24 [[VAL]]
;
  %src_gep = getelementptr inbounds i8, ptr %src, i64 2
  %dest_gep = getelementptr inbounds i8, ptr %src, i64 2
  call void @llvm.memcpy.p0.p0.i64(ptr %dest_gep, ptr %src_gep, i64 3, i1 false)
  %val = load i24, ptr %dest_gep
  ret i24 %val
}

declare void @llvm.memcpy.p0.p0.i64(ptr, ptr, i64, i1)
declare void @use_ptr(ptr)
